# -*- coding: utf-8 -*-
"""Implementation Of K-Nearest Neighbor Algorithm Using 5-Fold Cross-Validation On Pima India Diabetes Dataset To Generate The Highest Accuracy

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1rdF3-26C_uuUb1VKECX2wZBzxUWPxKeR

# IMPORTED LIBRARIES
"""

import numpy as np
import pandas
import io
from sklearn.preprocessing import StandardScaler
from sklearn.impute import SimpleImputer
from operator import itemgetter
from collections import Counter
from google.colab import files

"""# CONSTANTS AND GLOBAL VARIABLES"""

k = 3
AverageValidation = []
iterationA = 20
iterationB = 5

"""# IMPORTED/READ DATA"""

uploaded = files.upload()
df = pandas.read_csv(io.BytesIO(uploaded['Diabetes.csv']))

"""#DIVIDE AS ARRAY LISTS"""

x = df.iloc[:,:-1]
y = df['Outcome'].values

"""#IN CASE OF MISSING VALUE"""

x = x.replace(0, np.nan)

imp_mean = SimpleImputer(missing_values=np.nan, strategy='mean')
imp_mean.fit(x)
x = imp_mean.transform(x)

"""#CALCULATING THE MANHATTAN DISTANCE"""

def manhattan(x1, x2):   
  return np.sum(np.abs(np.array(x1)-np.array(x2)))

"""#CALCULATING THE EUCLIDEAN DISTANCE"""

def euclidean(x1, x2):
  return np.sqrt(np.sum((np.array(x1)-np.array(x2))**2))

"""#KNN CLASSIFICATION"""

def kNN(k):
  result = []
  hyperparameter = []
  kset = []
  for i in testing_x:
    result = []
    for j in training_x:
      result.append(manhattan(i, j))
    sorting = np.argsort(result)[:k]
    for l in sorting:
      kset.append(training_y[l])
    mode = Counter(kset).most_common(1)[0][0]
    kset = []
    hyperparameter.append(mode)
  return hyperparameter

"""# BEST VALUE OF K AND AVERAGE ACCURACY CALCULATION"""

for i in range(iterationA):
  Accuracy = 0
  for j in range(iterationB):
    if j == 0:
      training_x = x[:614]
      training_y = y[:614]
      testing_x = x[614:]
      testing_y = y[614:]
    elif j == 1:
      training_x = np.concatenate((x[:461], x[614:]))
      training_y = np.concatenate((y[:461], y[614:]))
      testing_x = x[461:614]
      testing_y = y[461:614]
    elif j == 2:
      training_x = np.concatenate((x[:307], x[461:]))
      training_y = np.concatenate((y[:307], y[461:]))
      testing_x = x[307:461]
      testing_y = y[307:461]
    elif j == 3:
      training_x = np.concatenate((x[:154], x[307:]))
      training_y = np.concatenate((y[:154], y[307:]))
      testing_x = x[154:307]
      testing_y = y[154:307]
    elif j == 4:
      training_x = x[:155]
      training_y = y[:155]
      testing_x = x[155:]
      testing_y = y[155:]
    scaler = StandardScaler()
    training_x = scaler.fit_transform(training_x)
    testing_x = scaler.transform(testing_x)
    Accuracy += (np.sum(kNN(k) == testing_y) / len(testing_y))*100
  print(" For K value of =",k,", the average accuracy is = ", Accuracy/5)
  AverageValidation.append([k, Accuracy/5])
  AverageValidation = sorted(AverageValidation, key=itemgetter(1), reverse=True)
  k += 1
print('K = ', AverageValidation[0][0], ', is the best value of K, which has the accuracy of = ', AverageValidation[0][1])